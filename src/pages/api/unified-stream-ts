// src/pages/api/unified-stream.ts

export const config = {
  api: {
    bodyParser: {
      sizeLimit: "10mb",
    },
  },
};

import type { NextApiRequest, NextApiResponse } from "next";
import OpenAI from "openai";
import { createPagesServerClient } from "@supabase/auth-helpers-nextjs";

import { supabaseAdmin } from "../../lib/supabaseAdmin";
import { parseUploadedFile } from "../../pages/api/session/utils/parseFiles";
import { loadIdentity } from "../../companions/identity/loader";
import { createSession, getMessages, saveMessage, saveTone } from "../../lib/memory";

import type { SalarMode } from "../../companions/orchestrators/salar";
import type { LyraMode } from "../../companions/orchestrators/lyra";

import {
  buildSalarStreamingPlan,
  type SalarStreamingPlanInput,
} from "../../companions/orchestrators/salar";

import {
  buildLyraStreamingPlan,
  type LyraStreamingPlanInput,
} from "../../companions/orchestrators/lyra";

type CompanionSlug = "salar" | "lyra";

interface UnifiedRequestBody {
  companion?: CompanionSlug;
  mode: string;
  tone?: string;
  input?: string | null;
  nextAction?: string | null;
  filePayload?: any;
  userId?: string | null;
  sessionId?: string | null;
}

export interface ConversationTurn {
  role: "user" | "assistant" | "system";
  content: string;
  meta?: any;
}

/* ---------------- Helpers ---------------- */

async function getGuestUserId(): Promise<string> {
  const { data, error } = await supabaseAdmin
    .from("user_profiles")
    .select("id")
    .eq("email", "guest@kora.local")
    .single();

  if (error || !data?.id) {
    throw new Error("Guest user profile not found");
  }

  return data.id;
}

function parseBody(req: NextApiRequest): UnifiedRequestBody {
  if (typeof req.body === "string") return JSON.parse(req.body);
  return req.body as UnifiedRequestBody;
}

// SSE helpers
function sseInit(res: NextApiResponse) {
  res.status(200);
  res.setHeader("Content-Type", "text/event-stream; charset=utf-8");
  res.setHeader("Cache-Control", "no-cache, no-transform");
  res.setHeader("Connection", "keep-alive");
  // Prevent buffering by some proxies
  res.setHeader("X-Accel-Buffering", "no");
  // CORS (same-origin in your case, but safe)
  res.setHeader("Access-Control-Allow-Origin", "*");
  // Flush headers if available
  // @ts-ignore
  res.flushHeaders?.();
}

function sseSend(res: NextApiResponse, data: any) {
  res.write(`data: ${JSON.stringify(data)}\n\n`);
}

function ssePing(res: NextApiResponse) {
  // comment line keeps connection alive without triggering message handlers
  res.write(`: ping\n\n`);
}

/* ---------------- Handler ---------------- */

const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY! });

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  console.log("üü¶ unified-stream.ts: Incoming request:", req.method);

  if (req.method !== "POST") {
    return res.status(405).json({ error: "Method not allowed" });
  }

  // Start SSE right away
  sseInit(res);

  // Heartbeat to keep mobile/proxies alive
  const heartbeat = setInterval(() => {
    try {
      ssePing(res);
    } catch {}
  }, 15_000);

  // Abort streaming if client disconnects
  const abortController = new AbortController();
  req.on("close", () => {
    abortController.abort();
    clearInterval(heartbeat);
  });

  try {
    const body = parseBody(req);

    let {
      companion = "salar",
      mode,
      tone = "calm",
      input = "",
      nextAction = null,
      filePayload,
      sessionId: incomingSessionId,
    } = body;

    if (!mode) {
      sseSend(res, { type: "error", error: "Missing mode in request." });
      clearInterval(heartbeat);
      return res.end();
    }

    const isGuest = req.headers["x-guest"] === "true";

    /* ---------- USER ID HANDLING (match unified.ts) ---------- */
    let userId: string | null = null;

    if (isGuest) {
      userId = await getGuestUserId();
    } else {
      const supabase = createPagesServerClient({ req, res });
      const {
        data: { user },
        error: authError,
      } = await supabase.auth.getUser();

      if (authError || !user) {
        sseSend(res, { type: "error", error: "Not authenticated" });
        clearInterval(heartbeat);
        return res.end();
      }

      userId = user.id;
    }

    /* ---------- FILE HANDLING (match unified.ts) ---------- */
    let extractedText = "";
    if (filePayload) {
      try {
        extractedText = await parseUploadedFile(filePayload, filePayload.type);
      } catch (err) {
        console.error("‚ùå File parse error:", err);
        sseSend(res, { type: "error", error: "File parsing failed." });
        clearInterval(heartbeat);
        return res.end();
      }
    }

    /* ---------- SESSION HANDLING (match unified.ts) ---------- */
    let sessionId = incomingSessionId || null;

    if (!sessionId) {
      const newSession = await createSession(userId, companion, "general");
      sessionId = newSession.id;
    }

    const rawHistory = await getMessages(sessionId as string);
    const conversationHistory: ConversationTurn[] = rawHistory.map((m: any) => ({
      role: m.role,
      content: m.content,
      meta: m.meta || null,
    }));

    /* ---------- SAVE USER MESSAGE (match unified.ts) ---------- */
    const trimmed =
      input?.trim() || (extractedText ? "User uploaded a document for analysis." : "");

    if (trimmed || nextAction) {
      const userContent = trimmed || `[Triggered Action: ${nextAction}]`;

      await saveMessage(sessionId as string, "user", userContent, {
        meta: {
          nextAction: nextAction || undefined,
          mode,
          companion,
        },
      });
    }

    /* ---------- BUILD STREAMING PLAN (prompt + meta + attachments plan) ---------- */
    // rawIdentity is still used as a safe fallback identity in case meta doesn't include identity
    const rawIdentity = loadIdentity(companion, mode);

    const plan =
      companion === "salar"
        ? buildSalarStreamingPlan({
            mode: mode as SalarMode,
            input: trimmed,
            extractedText,
            tone,
            nextAction: nextAction || undefined,
            conversationHistory,
          } as SalarStreamingPlanInput)
        : buildLyraStreamingPlan({
            mode: mode as LyraMode,
            input: trimmed,
            extractedText,
            tone,
            nextAction: nextAction || undefined,
            conversationHistory,
          } as LyraStreamingPlanInput);

    // Tell the client we‚Äôre starting an assistant reply
    sseSend(res, { type: "start", sessionId });

    /* ---------- STREAM OPENAI TOKENS ---------- */
    let fullText = "";

    const stream = await openai.responses.stream(
      {
        model: plan.model || "gpt-4.1",
        input: plan.fullPrompt,
      },
      { signal: abortController.signal as any }
    );

    for await (const event of stream) {
      if (abortController.signal.aborted) break;

      // The Responses streaming API emits typed events; we only forward text deltas
      // event.type examples include: "response.output_text.delta"
      // @ts-ignore
      if (event?.type === "response.output_text.delta") {
        // @ts-ignore
        const delta = event.delta || "";
        if (delta) {
          fullText += delta;
          sseSend(res, { type: "token", value: delta });
        }
      }
    }

    if (abortController.signal.aborted) {
      clearInterval(heartbeat);
      return res.end();
    }

    // Ensure we end up with the final output text (some SDKs also provide it at end)
    const finalReply = fullText.trim() || "No response generated.";

    /* ---------- POST-PROCESS: attachments + meta ---------- */
    const attachments = await plan.buildAttachments(finalReply);

    const metaFromPlan = plan.buildMeta(finalReply);

    const meta = {
      ...metaFromPlan,
      companion,
      mode,
      tone,
      identity:
        metaFromPlan.identity ??
        ({
          persona: rawIdentity?.persona,
          toneBase:
            typeof rawIdentity?.tone === "string"
              ? rawIdentity.tone
              : rawIdentity?.tone?.base,
          mode,
        } as any),
      memory: {
        shortTerm: conversationHistory.slice(-8),
      },
    };

    /* ---------- SAVE ASSISTANT MESSAGE (match unified.ts) ---------- */
    await saveMessage(sessionId as string, "assistant", finalReply, {
      attachments,
      meta,
    });

    if (userId) {
      await saveTone(userId, companion, tone || "calm", "post-response update");
    }

    /* ---------- FINAL EVENT ---------- */
    sseSend(res, {
      type: "done",
      reply: finalReply,
      attachments,
      meta,
      sessionId,
    });

    clearInterval(heartbeat);
    return res.end();
  } catch (err: any) {
    console.error("‚ùå unified-stream.ts error:", err);

    try {
      sseSend(res, { type: "error", error: err?.message || "Unknown error" });
    } catch {}

    clearInterval(heartbeat);
    return res.end();
  }
}